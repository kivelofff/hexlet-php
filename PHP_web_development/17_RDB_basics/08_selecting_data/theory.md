Выборка данных—
Основы реляционных баз данных
Операция SQL, с которой чаще всего соприкасаются программисты, — SELECT. В типичных веб-приложениях данные выбираются в 10 раз чаще, чем модифицируются. SELECT невероятно мощная команда, и именно большая часть вопросов на собеседованиях посвящена умению ею пользоваться.

В самостоятельной работе одного из прошлых уроков был указан репозиторий pg-dump-example, в котором содержится структура и данные для БД hexlet. Если вы еще не загрузили данные в базу, то самое время это сделать. Не забудьте выполнять все запросы этого урока в базе hexlet через REPL psql.

Самая простая форма запроса SELECT выглядит так:

SELECT всех полей из таблицы

SELECT * FROM users;
Этот запрос достает все содержимое таблицы users. Звездочка в данном примере означает "все поля". Если поля нужны не все, то достаточно перечислить их через запятую (вместо звездочки):

SELECT только определенных полей

SELECT username, email FROM users;
Поля не обязательно перечислять в том же порядке, в котором они идут в таблице. Более того, в результате такого запроса порядок полей в выводе будет соответствовать не тому, что в таблице, а тому, что указано в части SELECT.

На практике выборка, которая извлекает все записи, встречается редко из-за объемов таблиц и необходимости ограничивать вывод для конкретного пользователя. В этом случае используется WHERE, который мы рассматривали в прошлом уроке. Он работает одинаково вне зависимости от типа выполняемого запроса, будь-то UPDATE, DELETE или SELECT.

-- После WHERE указывается имя поля, которое сравнивается с некоторым значением (это один из вариантов)
-- Выбираем всех пользователей, родившихся ранее 21 октября 2018 года
SELECT * FROM users WHERE birthday < '2018-10-21';
И даже в таком варианте количество возможных записей может быть слишком большим. Думаю, вы не раз видели пейджинг на страницах поисковых систем, когда результаты поиска разбиваются на страницы по 10 элементов, а пейджинг позволяет перемещаться по ним. Конечно, этот механизм можно реализовать целиком в коде. Но так не делают, потому что количество данных, перегоняемых из базы данных в код, может быть огромным. На такую задачу не хватит никаких ресурсов сервера. Поэтому пейджинг реализуют на уровне базы данных. Для его реализации используют LIMIT.

SELECT * FROM users LIMIT 3;
Этот запрос выберет не больше 3-х записей. Если в таблице их меньше, то выберутся все, что есть: 0, 1 или 2. Меняя количество записей в лимите, мы увеличиваем или уменьшаем выборку.

Однако, SQL НЕ гарантирует никакого порядка в выборках выше. Если явно не указать сортировку, то мы не можем достоверно знать, в каком порядке вернутся данные. Поэтому в подобных выборках всегда присутствует секция ORDER BY:

SELECT * FROM users ORDER BY birthday;
Такой запрос отсортирует данные по ключу birthday в прямом порядке: кто родился раньше — будет выше. Если нужно отсортировать в обратном порядке, то надо добавить ключевое слово DESC (англ. descending — "убывающий").

SELECT * FROM users ORDER BY birthday DESC;
На этом базовые возможности SELECT заканчиваются. Все части запроса, которые мы рассмотрели, комбинируются друг с другом и даже могут использоваться одновременно:

-- Порядок следования частей `WHERE`, `ORDER BY` и `LIMIT` в SQL запросе фиксирован.
SELECT username, created_at FROM users WHERE birthday < '2018-10-21' ORDER BY birthday DESC LIMIT 2;
Для удобства, длинные запросы разбивают на строчки:

SELECT
username,
created_at
FROM users
WHERE birthday < '2018-10-21'
ORDER BY birthday DESC
LIMIT 2;
В будущих уроках мы рассмотрим каждую из этих частей подробнее.

Дополнительные материалы
SELECT